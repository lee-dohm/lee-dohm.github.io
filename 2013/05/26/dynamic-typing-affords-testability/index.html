<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <link href='https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic|Raleway' rel='stylesheet' type='text/css'>

    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link type="application/atom+xml" rel="alternate" href="https://www.lee-dohm.com/feed.xml" title="lee-dohm.com" />
    <link rel="icon" type="image/png" href="/favicon-icon.png"/>

    <!-- Bootstrap -->
    <link href="/bootstrap/css/bootstrap.min.css" rel="stylesheet" media="screen" />

    <!-- Site -->
    <link href="/stylesheets/styles.css" rel="stylesheet" />

    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

    <!-- MathJax -->
    <script type="text/javascript"
      src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    </script>

    <!-- Battle for the Net widget https://github.com/fightforthefuture/battleforthenet-widget -->
    <!-- <script src="https://widget.battleforthenet.com/widget.js" async></script> -->

    <!-- analytics.html -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-17382346-2', 'lee-dohm.com');
  ga('send', 'pageview');
</script>

    <!-- Begin Jekyll SEO tag v2.6.1 -->
<title>Dynamic Typing Affords Testability | lee-dohm.com</title>
<meta name="generator" content="Jekyll v4.1.0" />
<meta property="og:title" content="Dynamic Typing Affords Testability" />
<meta name="author" content="Lee Dohm" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="I read this article on language design “deal breakers”. It is a thought-provoking read despite the fact that the author and I do not agree on a couple key points. Where we do agree is with regards to memory safety, both in allocation and with respect to null references, and efficient storage reclamation. I’m much less concerned than the author about Windows support though I can understand why someone would include it in their “deal breaker” list. Where I definitely don’t agree is on the benefits of static typing and this reminded me that I had been meaning to write about dynamic typing and how it affords testability." />
<meta property="og:description" content="I read this article on language design “deal breakers”. It is a thought-provoking read despite the fact that the author and I do not agree on a couple key points. Where we do agree is with regards to memory safety, both in allocation and with respect to null references, and efficient storage reclamation. I’m much less concerned than the author about Windows support though I can understand why someone would include it in their “deal breaker” list. Where I definitely don’t agree is on the benefits of static typing and this reminded me that I had been meaning to write about dynamic typing and how it affords testability." />
<link rel="canonical" href="https://www.lee-dohm.com/2013/05/26/dynamic-typing-affords-testability/" />
<meta property="og:url" content="https://www.lee-dohm.com/2013/05/26/dynamic-typing-affords-testability/" />
<meta property="og:site_name" content="lee-dohm.com" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2013-05-26T19:48:38-07:00" />
<script type="application/ld+json">
{"datePublished":"2013-05-26T19:48:38-07:00","url":"https://www.lee-dohm.com/2013/05/26/dynamic-typing-affords-testability/","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.lee-dohm.com/2013/05/26/dynamic-typing-affords-testability/"},"author":{"@type":"Person","name":"Lee Dohm"},"description":"I read this article on language design “deal breakers”. It is a thought-provoking read despite the fact that the author and I do not agree on a couple key points. Where we do agree is with regards to memory safety, both in allocation and with respect to null references, and efficient storage reclamation. I’m much less concerned than the author about Windows support though I can understand why someone would include it in their “deal breaker” list. Where I definitely don’t agree is on the benefits of static typing and this reminded me that I had been meaning to write about dynamic typing and how it affords testability.","headline":"Dynamic Typing Affords Testability","dateModified":"2013-05-26T19:48:38-07:00","@type":"BlogPosting","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->


    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
      <script src="../../assets/js/html5shiv.js"></script>
      <script src="../../assets/js/respond.min.js"></script>
    <![endif]-->
  </head>
  <body>
    <nav class="navbar navbar-custom" role="navigation">
      <div class="navbar-header">
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
          <span class="sr-only">Toggle navigation</span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="/">Lee Dohm</a>
        <p class="navbar-text">Games and Technology Should Include EVERYone</p>
      </div>

      <div class="collapse navbar-collapse navbar-ex1-collapse">
        <ul class="nav navbar-nav navbar-right">
          <li><a href="/archives">Archive</a></li>
          <li><a href="/feed.xml">Feed</a></li>
          <li class="dropdown">
            <a href="#" class="dropdown-toggle" data-toggle="dropdown">About <b class="caret"></b></a>
            <ul class="dropdown-menu">
              <li><a href="/about">About Lee</a></li>
              <li><a href="/this-blog">About This Blog</a></li>
              <li><a href="/appearances">Appearances</a></li>
              <li><a href="/colophon">Colophon</a></li>
              <li><a href="/disclaimer">Disclaimers</a></li>
            </ul>
          </li>
        </ul>
      </div>
    </nav>

    <div class="container">
      <div class="row">
        <div class="row">
          <div class="col-md-8 col-md-offset-2">
            

<div class="content">
  <h1><a class="title" href="/2013/05/26/dynamic-typing-affords-testability/">Dynamic Typing Affords Testability</a></h1>
  <!-- dateline.html -->
<h4 class="dateline">
  May 26, 2013
  •
  <a href="/2013/05/26/dynamic-typing-affords-testability/"><span class="octicon octicon-link"></span></a>
</h4>


  <p>I read <a href="http://sebastiansylvan.wordpress.com/2013/05/25/language-design-deal-breakers/">this article on language design “deal breakers”</a>. It is a thought-provoking read despite the fact that the author and I do not agree on a couple key points. Where we do agree is with regards to memory safety, both in allocation and with respect to null references, and efficient storage reclamation. I’m much less concerned than the author about Windows support though I can understand why someone would include it in their “deal breaker” list. Where I definitely don’t agree is on the benefits of static typing and this reminded me that I had been meaning to write about dynamic typing and how it affords testability.</p>

<p>The author states in their article:</p>

<blockquote>
  <p>Examples of code you probably don’t want to write unit tests for includes gameplay logic which gets written and rewritten twenty times before ship as the result of iteration. Having to write test harnesses and tests for all this throwaway code is madness. Then of course there’s code that’s just plain hard to unit test, such as graphics. The point is that pervasive unit testing is a fantasy - it may be feasible in some domains, but it’s certainly not the case everywhere.</p>
</blockquote>

<p>The author states that automated testing isn’t valuable in all cases. Part of that reason appears to be that the author rightly states that automated testing, even at the unit test level, is hard … at least in statically typed languages.</p>

<p>Let’s step back a moment and define our terms. A language can be considered “statically typed” if type correctness is checked at compile-time and “dynamically typed” if type correctness is not checked at compile-time.<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote">1</a></sup> What it means to be “type correct” varies from language to language, so we won’t examine a more formal definition of that here. Languages like Java and Go are statically typed while languages like Ruby and Python are dynamically typed.</p>

<p>I’m going to take a look at the problem from the point of view of <a href="http://en.wikipedia.org/wiki/Dependency_injection">dependency injection</a>. Dependency injection is a very important capability in testing software in an automated fashion. This is a simple example in Java:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">A</span>
<span class="o">{</span>
    <span class="kd">private</span> <span class="no">B</span> <span class="n">b</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">A</span><span class="o">(</span><span class="no">B</span> <span class="n">b</span><span class="o">)</span>
    <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">b</span> <span class="o">=</span> <span class="n">b</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">store</span><span class="o">()</span>
    <span class="o">{</span>
        <span class="c1">// Stores important things into the database</span>
        <span class="k">this</span><span class="o">.</span><span class="na">b</span><span class="o">.</span><span class="na">store</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>The class <code class="language-plaintext highlighter-rouge">A</code> depends on some <code class="language-plaintext highlighter-rouge">B</code> to store information in the database, whether <code class="language-plaintext highlighter-rouge">B</code> is a concrete class or simply an interface doesn’t really matter from the point of view of <code class="language-plaintext highlighter-rouge">A</code>. <code class="language-plaintext highlighter-rouge">A</code> is well-factored and, for a statically typed language, easily testable. If <code class="language-plaintext highlighter-rouge">B</code> is a class, we could test it this way:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">MockB</span> <span class="kd">extends</span> <span class="no">B</span>
<span class="o">{</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="n">storeCalled</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">store</span><span class="o">()</span>
    <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">storeCalled</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">ATest</span>
<span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">storeTest</span><span class="o">()</span>
    <span class="o">{</span>
        <span class="nc">MockB</span> <span class="n">b</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MockB</span><span class="o">();</span>
        <span class="no">A</span> <span class="n">a</span> <span class="o">=</span> <span class="k">new</span> <span class="no">A</span><span class="o">(</span><span class="n">b</span><span class="o">);</span>

        <span class="n">a</span><span class="o">.</span><span class="na">store</span><span class="o">();</span>

        <span class="k">assert</span><span class="o">(</span><span class="n">b</span><span class="o">.</span><span class="na">storeCalled</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>We simply create a descendant of <code class="language-plaintext highlighter-rouge">B</code> that stubs out the method we want to test and supply that to the constructor of <code class="language-plaintext highlighter-rouge">A</code>. If <code class="language-plaintext highlighter-rouge">B</code> is an interface, the code is almost identical:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">MockB</span> <span class="kd">implements</span> <span class="no">B</span>
<span class="o">{</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="n">storeCalled</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">store</span><span class="o">()</span>
    <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">storeCalled</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>At least in this very simplified example. If <code class="language-plaintext highlighter-rouge">B</code> had not one method, but ten or twenty then the <code class="language-plaintext highlighter-rouge">MockB</code> for that version would be much more complicated even if <code class="language-plaintext highlighter-rouge">store()</code> is all we wanted to override. At the very least, we would have to implement all of those methods to throw an exception of some sort.<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote">2</a></sup></p>

<p>But, as is sometimes the case in these situations, perhaps <code class="language-plaintext highlighter-rouge">B</code> is declared in a library that we don’t have the source to recompile from. And perhaps it is declared like this:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">B</span>
<span class="o">{</span>
    <span class="kd">public</span> <span class="kd">final</span> <span class="kt">void</span> <span class="nf">store</span><span class="o">()</span>
    <span class="o">{</span>
        <span class="c1">// Writes to the database</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>That <code class="language-plaintext highlighter-rouge">final</code> keyword means that subclasses of <code class="language-plaintext highlighter-rouge">B</code> cannot override the <code class="language-plaintext highlighter-rouge">store</code> method.<sup id="fnref:3" role="doc-noteref"><a href="#fn:3" class="footnote">3</a></sup> What does one do in this case? Well, this is where things get weird. Because <code class="language-plaintext highlighter-rouge">B</code> doesn’t implement an interface nor descend from any parent class that we can use in its stead,<sup id="fnref:4" role="doc-noteref"><a href="#fn:4" class="footnote">4</a></sup> we have to do some gymnastics to essentially work around the type system:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nc">MockB</span>
<span class="o">{</span>
    <span class="kd">private</span> <span class="kt">boolean</span> <span class="n">mock</span><span class="o">;</span>
    <span class="kd">private</span> <span class="no">B</span> <span class="n">b</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kt">boolean</span> <span class="n">storeCalled</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">MockB</span><span class="o">(</span><span class="kt">boolean</span> <span class="n">mock</span> <span class="o">=</span> <span class="kc">false</span><span class="o">)</span>
    <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">mock</span> <span class="o">=</span> <span class="n">mock</span><span class="o">;</span>

        <span class="k">if</span><span class="o">(!</span><span class="k">this</span><span class="o">.</span><span class="na">mock</span><span class="o">)</span>
        <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">b</span> <span class="o">=</span> <span class="k">new</span> <span class="no">B</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">store</span><span class="o">()</span>
    <span class="o">{</span>
        <span class="k">if</span><span class="o">(!</span><span class="k">this</span><span class="o">.</span><span class="na">mock</span><span class="o">)</span>
        <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">b</span><span class="o">.</span><span class="na">store</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="k">else</span>
        <span class="o">{</span>
            <span class="k">this</span><span class="o">.</span><span class="na">storeCalled</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Yes, this gets the job done. But this version of <code class="language-plaintext highlighter-rouge">MockB</code> is now part of our <em>production</em> code because <code class="language-plaintext highlighter-rouge">A</code> has to be rewritten to accept a <code class="language-plaintext highlighter-rouge">MockB</code> instead of a <code class="language-plaintext highlighter-rouge">B</code>. It is going to ship with our product and could be a source of bugs. It also will be a performance hit, albeit perhaps an infinitesimally small one. Every time <code class="language-plaintext highlighter-rouge">A</code> would have called a method on <code class="language-plaintext highlighter-rouge">B</code>, a check is made to see if we are testing or not … a check that shouldn’t need to be performed in production code. This is also a violation of the <a href="http://en.wikipedia.org/wiki/Single_responsibility_principle">Single Responsibility Principle</a>, in that this new class is responsible both for being a stand-in for <code class="language-plaintext highlighter-rouge">B</code> as well as being responsible for affording testing.</p>

<p>In a dynamically typed language though, such as Ruby, all of these concerns and code changes go away. Let’s take a look at the Ruby version of <code class="language-plaintext highlighter-rouge">A</code>:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">A</span>
  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
    <span class="vi">@b</span> <span class="o">=</span> <span class="n">b</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">store</span>
    <span class="c1"># Stores important things into the database</span>
    <span class="vi">@b</span><span class="p">.</span><span class="nf">store</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Because the type of the <code class="language-plaintext highlighter-rouge">b</code> parameter doesn’t matter, we can create a class that does exactly what we want, similar to the first version of <code class="language-plaintext highlighter-rouge">MockB</code> in Java above. And better yet, it doesn’t matter if <code class="language-plaintext highlighter-rouge">B</code> is a class or an interface, open or closed, the code for the test is the same, so all the different versions of <code class="language-plaintext highlighter-rouge">MockB</code> that we had to worry about for Java are not necessary in Ruby.</p>

<p>This is just one example of how dynamic typing makes completely automated testing significantly easier. Static typing may catch one small class of bugs sooner, but automated testing has the potential of catching <em>all</em> classes of bugs sooner.</p>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>These ideas are separate from the concepts of a “strongly typed” or “weakly typed” language, which do not have strict definitions. <a href="#fnref:1" class="reversefootnote" role="doc-backlink">↩</a></p>
    </li>
    <li id="fn:2" role="doc-endnote">
      <p>In Java though, this might run afoul of checked exceptions depending on how we decided to do it. <a href="#fnref:2" class="reversefootnote" role="doc-backlink">↩</a></p>
    </li>
    <li id="fn:3" role="doc-endnote">
      <p>There are similar challenges in other statically typed languages like C++ and C# where the author of a class can completely prevent subclassing as a means of providing dependency injection. <a href="#fnref:3" class="reversefootnote" role="doc-backlink">↩</a></p>
    </li>
    <li id="fn:4" role="doc-endnote">
      <p>In the case of Java, of course, it descends from <code class="language-plaintext highlighter-rouge">Object</code>, but that isn’t helpful here. <a href="#fnref:4" class="reversefootnote" role="doc-backlink">↩</a></p>
    </li>
  </ol>
</div>

</div>
</div>
</div>
</div>
</div></body></html>

          </div>
        </div>

        <div class="col-md-8 col-md-offset-2">
          <hr/>
          <div class="text-center">
            <p>
              <a href="mailto:lee@lee-dohm.com"><span class="octicon octicon-mail"></span></a>&nbsp;&nbsp;
              <a href="https://github.com/lee-dohm"><span class="octicon octicon-mark-github"></span></a>&nbsp;&nbsp;
              <a href="//stackoverflow.com/users/1954/lee"><i class="fa fa-stack-exchange"></i></a>&nbsp;&nbsp;
              <a href="https://twitter.com/leedohm"><i class="fa fa-twitter"></i></a>
            </p>
            <p>
              Copyright &copy; 2010-2022 by Lee Dohm
            </p>
          </div>
        </div>
      </div>
    </div>

    <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
    <script src="//code.jquery.com/jquery.js"></script>
    <script src="/bootstrap/js/bootstrap.min.js"></script>
    <script src="/javascripts/lightbox.min.js"></script>
  </body>
</html>
